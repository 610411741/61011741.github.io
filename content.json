{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://github.com/610411741/61011741.github.io","root":"/61011741.github.io/"},"pages":[],"posts":[{"title":"MyBatis的分页方式","slug":"blog12","date":"2021-12-15T07:35:42.000Z","updated":"2022-09-15T15:30:25.227Z","comments":true,"path":"2021/12/15/blog12/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2021/12/15/blog12/","excerpt":"","text":"当数据非常多时，不可能一次性显示出来，所以分页是必不可少的功能。这样可以减少服务器压力，提升速度和效率，使页面变得整洁美观 分页原理： 逻辑分页：Mybatis是如何通过我们设置的RowBounds来返回分页结果的原理：首先是将所有结果查询出来，然后通过计算offset和limit，只返回部分结果，操作在内存中进行，所以也叫内存分页。弊端：当数据量大的时候，肯定是不行的物理分页：直接为sql添加limit拦截器PageHelper，调用了startPage后，他会通过PageInterceptor对其后的第一个执行sql进行拦截拼接上limit语句 Limit分页：123&lt;if test=&quot;startPos!=null and pageSize!=null&quot;&gt; //加上Null判空 limit $&#123;startPos&#125;,$&#123;pageSize&#125;&lt;/if&gt; xml： 12345678910111213141516171819202122232425262728 &lt;select id=&quot;getUserInfo1&quot; parameterType=&quot;map&quot; &gt; select * from user &lt;if test=&quot;startPos!=null and pageSize!=null&quot;&gt; limit $&#123;startPos&#125;,$&#123;pageSize&#125; &lt;/if&gt; &lt;/select&gt; List&lt;User&gt; getUserInfo1(Map&lt;String,Object&gt; map);测试：@Test public void selectUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); //这里塞值 Map&lt;String,Object&gt; parms = new HashMap&lt;&gt;(); parms.put(&quot;startPos&quot;,&quot;0&quot;); parms.put(&quot;pageSize&quot;,&quot;5&quot;); List&lt;User&gt; users = mapper.getUserInfo1(parms); for (User map: users)&#123; System.out.println(map); &#125; session.close();&#125; RowBounds分页 RowBounds帮我们省略了limit的内容，我们只需要在业务层关注分页即可！无须再传入指定数据！但是，这个属于逻辑分页，即实际上sql查询的是所有的数据，在业务层进行了分页而已，比较占用内存，而且数据更新不及时，可能会有滞后情况。RowBounds对象有2个属性，offset和limit。 业务代码 12345678910111213141516171819@Test public void selectUserRowBounds() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class);// List&lt;User&gt; users = session.selectList(&quot;com.dy.mapper.UserMapper.getUserInfoRowBounds&quot;,null,new RowBounds(0, 5)); List&lt;User&gt; users = mapper.getUserInfoRowBounds(new RowBounds(0,5)); for (User map: users)&#123; System.out.println(map); &#125; session.close(); &#125; List&lt;User&gt; getUserInfoRowBounds(RowBounds rowBounds);&lt;select id=&quot;getUserInfoRowBounds&quot; resultType=&quot;dayu&quot;&gt; select * from user&lt;/select&gt; PageHelper分页插件此分页插件被广泛使用再项目中，简单实用，屡试不爽。 在Pom.xml中导入jar包：12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.7&lt;/version&gt;&lt;/dependency&gt; 配置MyBatis 123 &lt;plugins&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot; /&gt;&lt;/plugins&gt; 业务代码: 123456789101112131415161718192021222324252627282930313233343536 @Test public void selectUserPageHelper() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); //第二种，Mapper接口方式的调用，推荐这种使用方式。 PageHelper.startPage(1, 3); List&lt;User&gt; list = mapper.getUserInfo(); //用PageInfo将包装起来 PageInfo page = new PageInfo(list); for (User map: list)&#123; System.out.println(map); &#125; System.out.println(&quot;page:---&quot;+page); session.close(); &#125;### 总结实用的还是PageHelper，他也是物理分页。但在一些项目中也运用mapp接口方式：```//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;User&gt; list = userMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;User&gt; list = userMapper.selectIf(1);//第四种，参数方法调用//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;User&gt; selectByPageNumSize( @Param(&quot;user&quot;) User user, @Param(&quot;pageNum&quot;) int pageNum, @Param(&quot;pageSize&quot;) int pageSize);&#125;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/610411741/61011741.github.io/tags/Mybatis/"}],"author":"Tian Lin"},{"title":"Redis延迟队列","slug":"blog11","date":"2021-10-17T13:10:08.000Z","updated":"2022-09-15T15:50:46.831Z","comments":true,"path":"2021/10/17/blog11/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2021/10/17/blog11/","excerpt":"","text":"首先看下以下两种业务情况： 如果有订单一直处于未支付状态时，如何及时的关闭订单，并且退还库存？ 创建新店铺时，很多天未上传商品，系统如何知道该情况，并发送激活短信？上述场景最简单直接的解决方案是定时扫表。我们假设 30分钟未支付则关闭订单、定时任务设置为 5 分钟一次，那么一个订单最晚会在 30分钟关闭。高达 5 分钟的误差是业务难以接受的。另一方面频繁的扫表可能消耗过多数据库资源，影响线上交易吞吐量。还有人使用 Redis 的过期通知、时间轮、Java 的 DelayQueue 等方式实现延时任务。但他们有缺陷：比如使用 Redis 过期通知不保证准时、发送即忘不保证送达，时间轮缺乏持久化机制容易丢失等。所以有必要做个rdis延迟队列，延迟队列得满足以下几个条件： 定时尽量精确 确认重试机制: 任务处理失败或超时应该有重试 持久化: 服务重启或崩溃不能丢失任务 其实可以用RocketMQ，Kafka等专业消息队列的延时投递功能,不过引入新的中间件通常存在各种非技术方面的麻烦。Redis 作为广泛使用的中间件，何不用 Redis 来制作延时队列呢？ 除了基本的延时投递之外我们的消息队列具有下列优势： 提供 ACK 和重试机制 只需要 Redis 和消费者即可运行，无需其它组件 提供 At-Least-One 投递语义、并保证消息不会并发消费 实现： 注册处理消息的回调函数 12345678910111213141516171819202122232425262728293031package main import ( &quot;github.com/go-redis/redis/v8&quot; &quot;github.com/hdt3213/delayqueue&quot; &quot;strconv&quot; &quot;time&quot;) func main() &#123; redisCli := redis.NewClient(&amp;redis.Options&#123; Addr: &quot;127.0.0.1:6379&quot;, &#125;) queue := delayqueue.NewQueue(&quot;example-queue&quot;, redisCli, func(payload string) bool &#123; // 注册处理消息的回调函数 // 返回 true 表示已成功消费，返回 false 消息队列会重新投递次消息 return true &#125;) // 发送延时消息 for i := 0; i &lt; 10; i++ &#123; err := queue.SendDelayMsg(strconv.Itoa(i), time.Hour, delayqueue.WithRetryCount(3)) if err != nil &#123; panic(err) &#125; &#125; // 启动消费协程 done := queue.StartConsume() // 阻塞等待消费协程退出 &lt;-done&#125; 使用pending2ReadyScript 扫描消息ID并把它们移动到 ready 中: 12345678910-- keys: pendingKey, readyKey-- argv: currentTimelocal msgs = redis.call(&#x27;ZRangeByScore&#x27;, KEYS[1], &#x27;0&#x27;, ARGV[1]) -- 从 pending key 中找出已到投递时间的消息if (#msgs == 0) then return endlocal args2 = &#123;&#x27;LPush&#x27;, KEYS[2]&#125; -- 将他们放入 ready key 中for _,v in ipairs(msgs) do table.insert(args2, v) endredis.call(unpack(args2))redis.call(&#x27;ZRemRangeByScore&#x27;, KEYS[1], &#x27;0&#x27;, ARGV[1]) -- 从 pending key 中删除已投递的消息 ready2UnackScript 从 ready 中取出一条消息发送给消费者并放入 unack 中 123456-- keys: readyKey/retryKey, unackKey-- argv: retryTimelocal msg = redis.call(&#x27;RPop&#x27;, KEYS[1])if (not msg) then return endredis.call(&#x27;ZAdd&#x27;, KEYS[2], ARGV[1], msg)return msg unack2RetryScript 从 retry 中找出所有已到重试时间的消息并把它们移动到 unack 中： 12345678910111213141516-- keys: unackKey, retryCountKey, retryKey, garbageKey-- argv: currentTimelocal msgs = redis.call(&#x27;ZRangeByScore&#x27;, KEYS[1], &#x27;0&#x27;, ARGV[1]) -- 找到已到重试时间的消息if (#msgs == 0) then return endlocal retryCounts = redis.call(&#x27;HMGet&#x27;, KEYS[2], unpack(msgs)) -- 查询剩余重试次数for i,v in ipairs(retryCounts) do local k = msgs[i] if tonumber(v) &gt; 0 then -- 剩余次数大于 0 redis.call(&quot;HIncrBy&quot;, KEYS[2], k, -1) -- 减少剩余重试次数 redis.call(&quot;LPush&quot;, KEYS[3], k) -- 添加到 retry key 中 else -- 剩余重试次数为 0 redis.call(&quot;HDel&quot;, KEYS[2], k) -- 删除重试次数记录 redis.call(&quot;SAdd&quot;, KEYS[4], k) -- 添加到垃圾桶，等待后续删除 endendredis.call(&#x27;ZRemRangeByScore&#x27;, KEYS[1], &#x27;0&#x27;, ARGV[1]) -- 将已处理的消息从 unack key 中删除 ack处理信息的删除 1234567891011func (q *DelayQueue) ack(idStr string) error &#123; ctx := context.Background() err := q.redisCli.ZRem(ctx, q.unAckKey, idStr).Err() if err != nil &#123; return fmt.Errorf(&quot;remove from unack failed: %v&quot;, err) &#125; // msg key has ttl, ignore result of delete _ = q.redisCli.Del(ctx, q.genMsgKey(idStr)).Err() q.redisCli.HDel(ctx, q.retryCountKey, idStr) return nil&#125; 消息队列的核心就是每秒执行一次的 consume 函数，它负责调用上述脚本将消息转移到正确的集合中并回调 consumer 来消费消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func (q *DelayQueue) consume() error &#123; // 执行 pending2ready，将已到时间的消息转移到 ready err := q.pending2Ready() if err != nil &#123; return err &#125; // 循环调用 ready2Unack 拉取消息进行消费 var fetchCount uint for &#123; idStr, err := q.ready2Unack() if err == redis.Nil &#123; // consumed all break &#125; if err != nil &#123; return err &#125; fetchCount++ ack, err := q.callback(idStr) if err != nil &#123; return err &#125; if ack &#123; err = q.ack(idStr) &#125; else &#123; err = q.nack(idStr) &#125; if err != nil &#123; return err &#125; if fetchCount &gt;= q.fetchLimit &#123; break &#125; &#125; // 将 nack 或超时的消息放入重试队列 err = q.unack2Retry() if err != nil &#123; return err &#125; // 清理已达到最大重试次数的消息 err = q.garbageCollect() if err != nil &#123; return err &#125; // 消费重试队列 fetchCount = 0 for &#123; idStr, err := q.retry2Unack() if err == redis.Nil &#123; // consumed all break &#125; if err != nil &#123; return err &#125; fetchCount++ ack, err := q.callback(idStr) if err != nil &#123; return err &#125; if ack &#123; err = q.ack(idStr) &#125; else &#123; err = q.nack(idStr) &#125; if err != nil &#123; return err &#125; if fetchCount &gt;= q.fetchLimit &#123; break &#125; &#125; return nil&#125;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/610411741/61011741.github.io/tags/Redis/"}],"author":"Tian Lin"},{"title":"SpringCloud +jwt 鉴权网关","slug":"blog9","date":"2021-08-17T07:35:28.000Z","updated":"2022-09-15T15:49:44.225Z","comments":true,"path":"2021/08/17/blog9/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2021/08/17/blog9/","excerpt":"","text":"如今的项目微服务繁多复杂，如果每个微服务都要自己去写一个鉴权，那么代码冗余度非常高，所以我们一般把鉴权操作放到网关Gateway中。 在网关完成url的鉴权（一切的OPTION的请求全部放行，一切不存在的请求都拒绝访问） 将解析后的jwt token当做请求头传递到下游服务中 整合Spring Security Oauth2 Resource Server 前期需要搭建认证服务器以及使用Spring Security Oauth2 Resource Server资源服务器。 网关导入相关jar包 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt; 自定义授权管理器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * 自定义授权管理器，判断用户是否有权限访问 */@Component@Slf4jpublic class CustomReactiveAuthorizationManager implements ReactiveAuthorizationManager&lt;AuthorizationContext&gt; &#123; /** * 此处保存的是资源对应的权限，可以从数据库中获取 */ private static final Map&lt;String, String&gt; AUTH_MAP = Maps.newConcurrentMap(); @PostConstruct public void initAuthMap() &#123; AUTH_MAP.put(&quot;/user/findAllUsers&quot;, &quot;user.userInfo&quot;); AUTH_MAP.put(&quot;/user/addUser&quot;, &quot;ROLE_ADMIN&quot;); &#125; @Override public Mono&lt;AuthorizationDecision&gt; check(Mono&lt;Authentication&gt; authentication, AuthorizationContext authorizationContext) &#123; ServerWebExchange exchange = authorizationContext.getExchange(); ServerHttpRequest request = exchange.getRequest(); String path = request.getURI().getPath(); // 带通配符的可以使用这个进行匹配 PathMatcher pathMatcher = new AntPathMatcher(); String authorities = AUTH_MAP.get(path); log.info(&quot;访问路径:[&#123;&#125;],所需要的权限是:[&#123;&#125;]&quot;, path, authorities); // option 请求，全部放行 if (request.getMethod() == HttpMethod.OPTIONS) &#123; return Mono.just(new AuthorizationDecision(true)); &#125; // 不在权限范围内的url，全部拒绝 if (!StringUtils.hasText(authorities)) &#123; return Mono.just(new AuthorizationDecision(false)); &#125; return authentication .filter(Authentication::isAuthenticated) .filter(a -&gt; a instanceof JwtAuthenticationToken) .cast(JwtAuthenticationToken.class) .doOnNext(token -&gt; &#123; System.out.println(token.getToken().getHeaders()); System.out.println(token.getTokenAttributes()); &#125;) .flatMapIterable(AbstractAuthenticationToken::getAuthorities) .map(GrantedAuthority::getAuthority) .any(authority -&gt; Objects.equals(authority, authorities)) .map(AuthorizationDecision::new) .defaultIfEmpty(new AuthorizationDecision(false)); &#125;&#125; 处理token异常 1234567891011121314151617/** * 认证失败异常处理 */public class CustomServerAuthenticationEntryPoint implements ServerAuthenticationEntryPoint &#123; @Override public Mono&lt;Void&gt; commence(ServerWebExchange exchange, AuthenticationException ex) &#123; return Mono.defer(() -&gt; Mono.just(exchange.getResponse())) .flatMap(response -&gt; &#123; response.setStatusCode(HttpStatus.UNAUTHORIZED); String body = &quot;&#123;\\&quot;code\\&quot;:401,\\&quot;msg\\&quot;:\\&quot;token不合法或过期\\&quot;&#125;&quot;; DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8)); return response.writeWith(Mono.just(buffer)) .doOnError(error -&gt; DataBufferUtils.release(buffer)); &#125;); &#125;&#125; 当用户没有权限时： 1234567891011121314151617181920@Slf4jpublic class CustomServerAccessDeniedHandler implements ServerAccessDeniedHandler &#123; @Override public Mono&lt;Void&gt; handle(ServerWebExchange exchange, AccessDeniedException denied) &#123; ServerHttpRequest request = exchange.getRequest(); return exchange.getPrincipal() .doOnNext(principal -&gt; log.info(&quot;用户:[&#123;&#125;]没有访问:[&#123;&#125;]的权限.&quot;, principal.getName(), request.getURI())) .flatMap(principal -&gt; &#123; ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(HttpStatus.FORBIDDEN); String body = &quot;&#123;\\&quot;code\\&quot;:403,\\&quot;msg\\&quot;:\\&quot;您无权限访问\\&quot;&#125;&quot;; DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8)); return response.writeWith(Mono.just(buffer)) .doOnError(error -&gt; DataBufferUtils.release(buffer)); &#125;); &#125; 将token传递到下游服务器 123456789101112131415161718192021222324252627282930313233public class TokenTransferFilter implements WebFilter &#123; private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); static &#123; OBJECT_MAPPER.registerModule(new Jdk8Module()); OBJECT_MAPPER.registerModule(new JavaTimeModule()); &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; return ReactiveSecurityContextHolder.getContext() .map(SecurityContext::getAuthentication) .cast(JwtAuthenticationToken.class) .flatMap(authentication -&gt; &#123; ServerHttpRequest request = exchange.getRequest(); request = request.mutate() .header(&quot;tokenInfo&quot;, toJson(authentication.getPrincipal())) .build(); ServerWebExchange newExchange = exchange.mutate().request(request).build(); return chain.filter(newExchange); &#125;); &#125; public String toJson(Object obj) &#123; try &#123; return OBJECT_MAPPER.writeValueAsString(obj); &#125; catch (JsonProcessingException e) &#123; return null; &#125; &#125; 配置Yml 12345678910111213spring: application: name: gateway-auth cloud: nacos: discovery: server-addr: localhost:8847 gateway: routes: - id: user-provider uri: lb://user-provider predicates: - Path=/user/**","categories":[],"tags":[{"name":"SPringCloud","slug":"SPringCloud","permalink":"https://github.com/610411741/61011741.github.io/tags/SPringCloud/"}],"author":"Tian Lin"},{"title":"Redis淘汰机制","slug":"blog10","date":"2021-08-15T13:08:08.000Z","updated":"2022-09-15T15:52:26.391Z","comments":true,"path":"2021/08/15/blog10/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2021/08/15/blog10/","excerpt":"","text":"总所周知，redis是个基于内存的缓存数据库，那再内存没有空间存入新的空间的时候，redis是怎么处理的呢？ 答案是此时的redis会执行一些淘汰的策略，把一些垃圾数据给淘汰掉，腾出新的空间。redis6种淘汰策略 1.noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外） 2.allkeys-lru：从所有key中使用LRU算法进行淘汰（LRU算法：即最近最少使用算法） 3.volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰 4.allkeys-random：从所有key中随机淘汰数据 5.volatile-random：从设置了过期时间的key中随机淘汰 6.volatile-ttl：在设置了过期时间的key中，淘汰过期时间剩余最短的 当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误 查看当前的淘汰策略：config get maxmemory-policy 设置淘汰策略：1. maxmemory-policy allkeys-lru（修改redis.conf文件）2.命令修改 config set maxmemory-policy allkeys-lru 获取redis能使用的最大内存 config get maxmemory","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/610411741/61011741.github.io/tags/Redis/"}],"author":"Tian Lin"},{"title":"DocKer搭建本地开发环境","slug":"blog8","date":"2021-05-15T14:18:38.000Z","updated":"2022-09-15T09:16:51.381Z","comments":true,"path":"2021/05/15/blog8/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2021/05/15/blog8/","excerpt":"","text":"什么是DockerDocker简单来说就是一个开源的应用容器引擎，可以让程序开发人员打包应用及依赖包到一个可移植的容器中，再发布到Linux的机器上，也可以实现虚拟化。简而言之，就是一个便捷的应用容器。 安装Docker 在mac平台下，去下载一个dmg的安装文件。下载好了之后，双击，然后拖入就可以了，windows应该也是类似的。链接如下： https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q= 查看docker 版本信息，如果出现版本信息则表示安装成功。 安装docker-composer链接如下： https://github.com/docker/compose/releases 安装完成后输入命令检查 1234 ➜ ~ docker-compose versiondocker-compose version 1.23.2, build 1110ad01docker-py version: 3.6.0CPython version: 3.6.6 下载laradock到本地 https://github.com/laradock/laradock 配置env文件cp env- example env,看需求修改远程映射路径。 执行命令 docker-compose up -d nginx mysql 运行 配置项目信息：DB_CONNECTION=mysqlDB_HOST=mysqlDB_PORT=3306DB_DATABASE=blogDB_USERNAME=rootDB_PASSWORD=tl123456 注意，数据库主机必须得是别名 配置宿主机的 host vim /etc/hosts（可以加入自己设置的虚拟域名） 访问：url 结果：","categories":[],"tags":[{"name":"java docker","slug":"java-docker","permalink":"https://github.com/610411741/61011741.github.io/tags/java-docker/"}],"author":"Tian Lin"},{"title":"简单聊一聊单例模式","slug":"blog6","date":"2020-11-08T12:35:42.000Z","updated":"2022-09-15T08:22:37.161Z","comments":true,"path":"2020/11/08/blog6/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/11/08/blog6/","excerpt":"","text":"单例模式介绍： 单例模式的使用： 单例模式，顾名思义，要保证程序中只有这么一个单例，保证仅有一个实例。比如发号器，redis连接对象等 单例模式的分类：1.懒汉模式：简单来说就是懒加载，等到程序需要这个对象的时候再来创建，延迟创建对象。 2.饿汉：提前创建好对象，类加载就会导致该单实例对象被创建。 单例模式的实现步骤：1.私有化构造函数，例必须是一个且唯一，并且必须加上static属性。2.提供获取单例的方法 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @Description: 单例设计模式-懒汉式 */public class SingletonLazy &#123; // 当需要用到该实例的时候再创建实例对象 private static SingletonLazy instance; /** * 构造函数私有化 * 不能通过 new SingletonLazy() 的方式创建实例 * * 当需要用到该实例的时候在加载 * 只能通过 SingletonLazy.getInstance() 这种方式获取实例 */ private SingletonLazy() &#123; &#125; /** * 单例对象的方法 */ public void process() &#123; System.out.println(&quot;方法实例化成功！&quot;); &#125; /** * 方式一： * &lt;p&gt; * 对外暴露一个方法获取该类的对象 * &lt;p&gt; * 缺点：线程不安全，多线程下存在安全问题 * * @return */ public static SingletonLazy getInstance() &#123; if (instance == null) &#123;// 实例为null时候才创建 /** * 线程安全问题： * 当某一时刻，两个或多个线程同时判断到instance == null成立的时候 * 这些线程同时进入该if判断内部执行实例化 * 则会新建出不止一个SingletonLazy实例 */ instance = new SingletonLazy();// 当需要的时候再进行实例化对象 &#125; return instance; &#125; /** * 方式二： * 通过加synchronized锁 保证线程安全 * * 采用synchronized 对方法加锁有很大的性能开销 * 因为当getInstance2()内部逻辑比较复杂的时候，在高并发条件下 * 没获取到加锁方法执行权的线程，都得等到这个方法内的复杂逻辑执行完后才能执行，等待浪费时间，效率比较低 * * @return */ public static synchronized SingletonLazy getInstance2() &#123; if (instance == null) &#123;// 实例为null时候才创建 // 方法上加synchronized锁后可以保证线程安全 instance = new SingletonLazy();// 当需要的时候再进行实例化对象 &#125; return instance; &#125; /** * 方式三： * 在getInstance3()方法内，针对局部需要加锁的代码块加锁，而不是给整个方法加锁 * * 也存在缺陷： * @return */ public static SingletonLazy getInstance3() &#123; if (instance == null) &#123;// 实例为null时候才创建 // 局部加锁后可以保证线程安全,效率较高 // 缺陷：假设线程A和线程B synchronized (SingletonLazy.class)&#123; // 当线程A获得锁的执行权的时候B等待 A执行new SingletonLazy();实例化 // 当A线程执行完毕后，B再获得执行权，这时候还是可以实例化该对象 instance = new SingletonLazy();// 当需要的时候再进行实例化对象 &#125; &#125; return instance; &#125;&#125; 分析上述代码，可以发现方法3存在不足之处，我们可以对代码进行优化: 在getInstance3()方法内，针对局部需要加锁的代码块加锁，而不是给整个方法加锁 DCL 双重检查锁定 (Double-Checked-Locking) 在多线程情况下保持高性 这是否安全？ instance = new SingletonLazy(); 并不是原子性操作 jvm中 instance实例化内存模型流程如下： 1.分配空间给对象 2.在空间内创建对象 3.将对象赋值给instance引用 假如出现如下顺序错乱的情况： 线程的执行顺序为：1 -&gt; 3 -&gt; 2, 那么这时候会把值写回主内存 则，其他线程就会读取到instance的最新值,但是这个是不完全的对象 12345678910111213141516public static SingletonLazy getInstance3plus() &#123; if (instance == null) &#123;// 实例为null时候才创建 // 局部加锁后可以保证线程安全,效率较高 // 假设线程A和线程B synchronized (SingletonLazy.class)&#123;// 第一重检查 // 当线程A获得锁的执行权的时候B等待 A执行new SingletonLazy();实例化 // 当A线程执行完毕后，B再获得执行权，这时候再判断instance == null是否成立 // 如果不成立，B线程无法 实例化SingletonLazy if (instance == null)&#123;// 第二重检查 instance = new SingletonLazy();// 当需要的时候再进行实例化对象 &#125; &#125; &#125; return instance;&#125; 12345678910111213141516171819202122232425/** * @Description: 单例设计模式-饿汉式 */public class SingletonHungry &#123; // 当类加载的时候就直接实例化对象 private static SingletonHungry instance = new SingletonHungry(); private SingletonHungry()&#123;&#125; /** * 单例对象的方法 */ public void process() &#123; System.out.println(&quot;方法实例化成功！&quot;); &#125; /** * 饿汉创建的优点：不需要考虑线程安全的问题，实现比较简单 * 缺点：instance对象一直占用内存，耗费内存 */ public static SingletonHungry getInstance()&#123; return instance;// 当类加载的时候就直接实例化对象 &#125;&#125; 如何选择？个人觉得对象空间占用较小，创建简单的情况下用饿汉，其他的时候用懒汉。","categories":[],"tags":[{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://github.com/610411741/61011741.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Tian Lin"},{"title":"SpringCloud注册中心 Eureka常用的注解","slug":"Blog5","date":"2020-10-25T04:11:10.000Z","updated":"2022-09-15T07:55:51.780Z","comments":true,"path":"2020/10/25/Blog5/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/10/25/Blog5/","excerpt":"","text":"什么是EurekaEureka是SpringCloud的核心模块之一，Eureka是一个基于RestFul的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对与微服务来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类十余Dubbo的注册中心，比如Zookeepe. Eureka的相关注解： @EnableEurekaClient @EnableDiscoveryClient两个注解的异同及使用场景如下：@EnableDiscoveryClient和@EnableEurekaClient表示开启eureka客服端，都是能够让注册中心能够发现，扫描到改服务。上面两个注解都是用在应用的启动类上面，声明这是一个Eureka Client ，现在说明两个注解的区别。不同之处就是 @EnableEurekaClient 只适用于Eureka作为注册中心，而@EnableDiscoveryClient 可以是其他注册中心。 用法如下： 123456789@SpringBootApplication@EnableDiscoveryClient // 服务注册发现// @EnableEurekaClientpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class); &#125;&#125; @EnableEurekaServer开启eureka注册中心，为eureka server服务端， 可以接受其他的服务注册 12345678@SpringBootApplication// 开启 eureka server 服务端，接受别人注册@EnableEurekaServerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class); &#125;&#125;","categories":[],"tags":[{"name":"java SpinrgCloud","slug":"java-SpinrgCloud","permalink":"https://github.com/610411741/61011741.github.io/tags/java-SpinrgCloud/"}],"author":"Tian Lin"},{"title":"Spring Boot的@RequestParam @RequestBody @PathVariable 等参数绑定注解","slug":"blog4","date":"2020-10-15T04:10:10.000Z","updated":"2022-09-09T12:54:08.975Z","comments":true,"path":"2020/10/15/blog4/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/10/15/blog4/","excerpt":"","text":"1: @PathVariable1234567@Controller@RequestMapping(&quot;/user/&#123;userId&#125;&quot;)public class test &#123; public void findUser(@PathVariable String userId, Model model) &#123; &#125;&#125; 代码中将REquest url中的变量userID的值绑定到了方法的参数上。即使用 @PathVariable注解时可以将{*}的值绑定到方法的参数上 2：@RequestBody@RequestBody接收的参数是来自RequestBody中，即请求体。@RequestBody一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。 @RequestBody 接受的是一个Json格式的字符串，一定是一个字符串。我们写一个User类 定义一下成员变量： String userName String password@requestBody User user 这种形式会将JSON字符串中的值赋予user中对应的属性上。需要注意的是，JSON字符串中的key必须对应user中的属性名，否则是请求不过去的。 1234@requestMapping(&quot;/login&quot;)public void login(@requestBody User user)&#123; System.out.println(user.getUserName()+&quot; ：&quot;+user.getPwd());&#125; 3: @RequestParam该注解@RequestParam 三个常用属性： （1）value：浏览器请求传入的参数名，默认会将后面的方法参数名称作为接收的参数名。（2）required：是否必需，默认为 true，即请求中必须包含该参数，如果没有包含，将会抛出异常（可选配置）（3）defaultValue：当没有传入参数时，则使用此默认值。如果设置了该值，required 将自动设为 false，无论是否配置了required，配置了什么值，都是 false（可选配置）","categories":[],"tags":[{"name":"java SpringBoot","slug":"java-SpringBoot","permalink":"https://github.com/610411741/61011741.github.io/tags/java-SpringBoot/"}],"author":"Tian Lin"},{"title":"Autowired 和@Resource 新理解","slug":"blog7","date":"2020-09-08T12:35:28.000Z","updated":"2022-09-15T15:56:42.475Z","comments":true,"path":"2020/09/08/blog7/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/09/08/blog7/","excerpt":"","text":"今天偶然写代码的时候，看见项目中有waring的提示，如下： 12@Autowireprivate JdbcTemplate jdbcTemplate; 提示的警告信息：“Field injection is not recommended Inspection info: Spring Team recommends: “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.大概意思为注入方式不推荐。 其实注入方式就几种： 基于Setter的依赖注入12345678 public class UserServiceImpl implents UserService&#123; private UserDao userDao; @Autowire public serUserDao(UserDao userDao)&#123; this.userDao = userDao; &#125;&#125; 基于构造函数的依赖注入12345678public class UserServiceImpl implents UserService&#123; private UserDao userDao; @Autowire public UserServiceImpl(UserDao userDao)&#123; this.userDao = userDao; &#125;&#125; 基于字段的依赖注入1234 public class UserServiceImpl implents UserService&#123; @Autowire private UserDao userDao;&#125; 我们在开发中基本上是用字段依赖注入，因为简便明了。但其实这样用不好，sping不建议。Field注入的缺点 不能像构造器那样注入不可变的对象 依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖 会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难） 依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则 @Autowired VS @Resource事实上，他们的基本功能都是通过注解实现依赖注入，只不过@Autowired是Spring定义的，而@Resource是JSR-250定义的。大致功能基本相同，但是还有一些细节不同： 依赖识别方式：@Autowired默认是byType可以使用@Qualifier指定Name，@Resource默认ByName如果找不到则ByType适用对象：@Autowired可以对构造器、方法、参数、字段使用，@Resource只能对方法、字段使用提供方：@Autowired是Spring提供的，@Resource是JSR-250提供的各种DI方式的优缺点参考Spring官方文档，建议了如下的使用场景： 构造函数注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）Field注入：大多数情况下尽量少使用字段注入，一定要使用的话，@Resource相对@Autowired对IoC容器的耦合更低 那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？@Autowired是Spring提供的，而@Resource是JSR-250提供的，它是Java标准。","categories":[],"tags":[{"name":"java Spring","slug":"java-Spring","permalink":"https://github.com/610411741/61011741.github.io/tags/java-Spring/"}],"author":"Tian Lin"},{"title":"Spring 中的对象","slug":"Blog3","date":"2020-09-06T04:10:08.000Z","updated":"2022-09-08T08:52:06.017Z","comments":true,"path":"2020/09/06/Blog3/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/09/06/Blog3/","excerpt":"","text":"Spring 为什么被称作是一个容器？它里面的对象是谁创建的？以及相关属性是由谁设置的？ 我们举个例子来简单说明。编写一个Student的实体类： class Student &#123;1234567891011 private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;Student&#x27;s name is&quot;+ name ); &#125;&#125; 编写一个XML的文件","categories":[],"tags":[{"name":"java Spring","slug":"java-Spring","permalink":"https://github.com/610411741/61011741.github.io/tags/java-Spring/"}],"author":"Tian Lin"},{"title":"Spring 笔记","slug":"bLog2","date":"2020-07-20T12:08:20.000Z","updated":"2022-09-07T13:18:24.391Z","comments":true,"path":"2020/07/20/bLog2/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/07/20/bLog2/","excerpt":"","text":"Spring 的概述，几个常见的Spring的问题： Spring 是什么？ Spring的两大核心 Spring的发展历程和优势？ Spring 是什么？官网解释的非常详细和明了：官方地址： spring 为什么要用Spring呢？总结了以下有几点优点： 方便解耦，简化开发 控制反转 IoC , 面向切面 Aop 声明事物的支持以及对框架的支持 方便程序的测试以及继承各种优秀的框架 spring的组成：1.spring由七大模块组成：分别是Spring 核心容器（Spring Core）、应用上下文（Spring Context）、Spring面向切面编程（Spring AOP）、JDBC和DAO模块（Spring DAO）、对象实体映射（Spring ORM）、Web模块（Spring Web）以及MVC模块（SpringWebMVC）。 Spring核心容器：核心容器提供Spring框架开发的一些基本组成。核心容器的主要组件是BeanFactory，它是工厂模式的实现。 Spring ContextSpring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring Aop:通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO:DBC、DAO的抽象层，提供了有意义的异常层次结构实现，可用该结构来管理异常处理，和不同数据库提供商抛出的错误信息，异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。 Spring ORM:对象实体映射Spring ， 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map等。 Spring Web Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 SpringMVC: MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity等 IOC本质： &gt;- 控制反转是一种通过描述（XML或注解）并通过第三方去生产或产生特定对象的方式，在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入。（Dependency Injection 简称 DI）。OC的实现同样也需要一个过程：Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 实现完成后，彻底不用在程序中改动了，要实现不同的操作。只需要在XML配置文件中进行修改。 所谓IOC，便是：对象由Spring来创建，管理，装配。","categories":[],"tags":[{"name":"java Spring","slug":"java-Spring","permalink":"https://github.com/610411741/61011741.github.io/tags/java-Spring/"}],"author":"Tian Lin"},{"title":"简单聊一聊Spring/SpringBuilder/SpringBuffer","slug":"blog1","date":"2020-07-15T07:35:42.000Z","updated":"2022-09-08T08:52:35.002Z","comments":true,"path":"2020/07/15/blog1/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/07/15/blog1/","excerpt":"","text":"1.11.String 是不可变字符串，每对Spring进行编写后都会产生一个新的字符串对象。2.StringBuffer StringBuilder都是可变的字符串3.StringBuffer StringBuilder在功能以及用法上基本等价。但是StringBuffer中很多办法都用了Synchronized关键字进行修饰，所以线程比较安全，而StringBuilder中并没有用其修饰，所以它不安全，但是在单线程下，它不用每次判断锁，因此效率较高。 1.2String 对象不是一旦创建了就不改变了吗 ？ 那它常用的修改方法的值是怎么样实现的呢？拥有方法如下： substring(int,int) 字符串截取、split(String,int) 字符串分割、toLowerCase() 字符串所有字母小写。通过查看subString底层的源码可知：其实是重新new了一个新的对象来接受字符串，并不是重新修改了原来的值，所以本质上原来的String对象并没有发生改变 1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; 1.3StringBulider为什么又可变了呢？其实可以把他看作一个容器。Stringbulid 和String可以相互转换。String -&gt; StringBuilder:可以使用StringBuilder的构造方法 StringBuilder(String str)构造一个字符串生成器，并初始化为指定的字符串内容。 StringBuilder -&gt; String:可以使用StringBuilder中的toString方法 public String toString():将当前StringBuilder对象转换为String对象。Demo: 1234567891011public static void main(String[] args) &#123; //String -&gt; StringBuilder String str = &quot;Hello&quot;; System.out.println(str); StringBuilder stringBuilder = new StringBuilder(str); stringBuilder.append(&quot;World&quot;); System.out.println(stringBuilder); //StringBuilder -&gt; String String string = stringBuilder.toString(); System.out.println(string); &#125; 1.4StringBuffer StringBulider一样同其实也可以被看作一个容器。字符串类可变，StringBuffer 可以通过 toString()方法转换成 StringString 可以通过 StringBuffer 的构造方法，转换成 StringBuffer。 12String string = new StringBuffer().toString();StringBuffer stringBuffer = new StringBuffer(new String());","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/610411741/61011741.github.io/tags/java/"}],"author":"Tian Lin"},{"title":"关于@JsonFormat和@DataTimeFormat注解的日志相关问题","slug":"title","date":"2020-07-10T10:08:08.000Z","updated":"2022-09-07T09:39:07.855Z","comments":true,"path":"2020/07/10/title/","link":"","permalink":"https://github.com/610411741/61011741.github.io/2020/07/10/title/","excerpt":"","text":"注解@JsonFormat主要是后端到前端的时间格式的转换 注解@DateTimeFormat主要是前端到后台的时间格式的转换运用示例: 构造一个blog实体类：定义一些相关的成员变量对应数据库中表的字段123456789/** * 博客文章实体类 */public class Blog &#123; private Integer blog_id;// 博客id private String blog_title;// 博客标题 private String blog_content;// 博客内容 private Date blog_date;// 博客发布日期&#125; 如果我们不做任何处理，查出数据库中任何一篇博客时，得到的时间格式可能有点奇怪。比如如下：**”blog_date”: “2020-07-01T18:25:36.296+0000”** ，所以为了解决这个问题，就用到了 @JsonForMat这个注解。它能将日期格式化，此为 Jackson 框架提供的注解，将Date对象数据解析转换为JSON格式，该注解用于Date字段即可，同时指定期望JSON日期的格式。在日期字段上加上注解： 123456 public class Blog &#123; @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd&quot;) private Date blog_date;// 博客发布日期&#125; 而在大多用户前台的门面的用户中心业务时，可能有比如出生日期，发表博客的日期这些内容，有时候会出现前端传递到后端的时间不一致的情况，所以就要加上 @DataTimeFormat 这个注解.此为Spring框架提供的注解，将JSON格式的日期信息信息解析转换并绑定到Date对象中，该注解用于Date字段即可，同时指定JSON日期的格式即可 123456 public class Blog &#123; @DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date blog_date;// 博客发布日期&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/610411741/61011741.github.io/tags/java/"}],"author":"Tian Lin"}],"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/610411741/61011741.github.io/tags/Mybatis/"},{"name":"Redis","slug":"Redis","permalink":"https://github.com/610411741/61011741.github.io/tags/Redis/"},{"name":"SPringCloud","slug":"SPringCloud","permalink":"https://github.com/610411741/61011741.github.io/tags/SPringCloud/"},{"name":"java docker","slug":"java-docker","permalink":"https://github.com/610411741/61011741.github.io/tags/java-docker/"},{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://github.com/610411741/61011741.github.io/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java SpinrgCloud","slug":"java-SpinrgCloud","permalink":"https://github.com/610411741/61011741.github.io/tags/java-SpinrgCloud/"},{"name":"java SpringBoot","slug":"java-SpringBoot","permalink":"https://github.com/610411741/61011741.github.io/tags/java-SpringBoot/"},{"name":"java Spring","slug":"java-Spring","permalink":"https://github.com/610411741/61011741.github.io/tags/java-Spring/"},{"name":"java","slug":"java","permalink":"https://github.com/610411741/61011741.github.io/tags/java/"}]}