<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MyBatis的分页方式</title>
    <link href="/61011741.github.io/2021/12/15/blog12/"/>
    <url>/61011741.github.io/2021/12/15/blog12/</url>
    
    <content type="html"><![CDATA[<h2 id="当数据非常多时，不可能一次性显示出来，所以分页是必不可少的功能。这样可以减少服务器压力，提升速度和效率，使页面变得整洁美观"><a href="#当数据非常多时，不可能一次性显示出来，所以分页是必不可少的功能。这样可以减少服务器压力，提升速度和效率，使页面变得整洁美观" class="headerlink" title="当数据非常多时，不可能一次性显示出来，所以分页是必不可少的功能。这样可以减少服务器压力，提升速度和效率，使页面变得整洁美观"></a>当数据非常多时，不可能一次性显示出来，所以分页是必不可少的功能。这样可以减少服务器压力，提升速度和效率，使页面变得整洁美观</h2><blockquote><p>分页原理：</p></blockquote><blockquote><blockquote><p>逻辑分页：Mybatis是如何通过我们设置的RowBounds来返回分页结果的<br>原理：首先是将所有结果查询出来，然后通过计算offset和limit，只返回部分结果，操作在内存中进行，所以也叫内存分页。<br>弊端：当数据量大的时候，肯定是不行的<br>物理分页：直接为sql添加limit<br>拦截器PageHelper，调用了startPage后，他会通过PageInterceptor对其后的第一个执行sql进行拦截拼接上limit语句</p></blockquote></blockquote><h3 id="Limit分页："><a href="#Limit分页：" class="headerlink" title="Limit分页："></a>Limit分页：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;startPos!=null and pageSize!=null&quot;</span>&gt; //加上Null判空<br>    <span class="hljs-built_in">limit</span> <span class="hljs-variable">$&#123;startPos&#125;</span>,<span class="hljs-variable">$&#123;pageSize&#125;</span><br>&lt;/if&gt;<br></code></pre></td></tr></table></figure><p>xml：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    &lt;<span class="hljs-keyword">select</span> id=&quot;getUserInfo1&quot; parameterType=&quot;map&quot; &gt;<br>        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br>        &lt;<span class="hljs-keyword">if</span> test=&quot;startPos!=null and pageSize!=null&quot;&gt;<br>            <span class="hljs-keyword">limit</span> $&#123;startPos&#125;,$&#123;pageSize&#125;<br>        &lt;/<span class="hljs-keyword">if</span>&gt;<br>    &lt;/<span class="hljs-keyword">select</span>&gt;<br><br><br>    List&lt;<span class="hljs-keyword">User</span>&gt; getUserInfo1(Map&lt;String,<span class="hljs-keyword">Object</span>&gt; map);<br><br>测试：<br><br>@Test<br> <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> selectUser() &#123;<br>     SqlSession <span class="hljs-keyword">session</span> = MybatisUtils.getSession();<br>     UserMapper mapper = <span class="hljs-keyword">session</span>.getMapper(UserMapper.<span class="hljs-keyword">class</span>);<br>     //这里塞值<br>      Map&lt;String,<span class="hljs-keyword">Object</span>&gt; parms = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>      parms.put(&quot;startPos&quot;,&quot;0&quot;);<br>      parms.put(&quot;pageSize&quot;,&quot;5&quot;);<br>     List&lt;<span class="hljs-keyword">User</span>&gt; users = mapper.getUserInfo1(parms);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">User</span> map: users)&#123;<br>         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map);<br>    &#125;<br>     <span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h3><ul><li>RowBounds帮我们省略了limit的内容，我们只需要在业务层关注分页即可！无须再传入指定数据！<br>但是，这个属于逻辑分页，即实际上sql查询的是所有的数据，在业务层进行了分页而已，比较占用内存，而且数据更新不及时，可能会有滞后情况。<br>RowBounds对象有2个属性，offset和limit。</li></ul><blockquote><p>  业务代码</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> selectUserRowBounds() &#123;<br>        SqlSession <span class="hljs-keyword">session</span> = MybatisUtils.getSession();<br>        UserMapper mapper = <span class="hljs-keyword">session</span>.getMapper(UserMapper.<span class="hljs-keyword">class</span>);<br>//        List&lt;<span class="hljs-keyword">User</span>&gt; users = <span class="hljs-keyword">session</span>.selectList(&quot;com.dy.mapper.UserMapper.getUserInfoRowBounds&quot;,<span class="hljs-keyword">null</span>,<span class="hljs-built_in">new</span> RowBounds(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>));<br>        List&lt;<span class="hljs-keyword">User</span>&gt; users = mapper.getUserInfoRowBounds(<span class="hljs-built_in">new</span> RowBounds(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">User</span> map: users)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map);<br>        &#125;<br>        <span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>    &#125;<br><br><br> List&lt;<span class="hljs-keyword">User</span>&gt; getUserInfoRowBounds(RowBounds rowBounds);<br><br><br>&lt;<span class="hljs-keyword">select</span> id=&quot;getUserInfoRowBounds&quot; resultType=&quot;dayu&quot;&gt;<br>        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="PageHelper分页插件"><a href="#PageHelper分页插件" class="headerlink" title="PageHelper分页插件"></a>PageHelper分页插件</h3><p>此分页插件被广泛使用再项目中，简单实用，屡试不爽。</p><ul><li>在Pom.xml中导入jar包：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>配置MyBatis</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>  <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>业务代码:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  @Test<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> selectUserPageHelper() &#123;<br>        SqlSession <span class="hljs-keyword">session</span> = MybatisUtils.getSession();<br>        UserMapper mapper = <span class="hljs-keyword">session</span>.getMapper(UserMapper.<span class="hljs-keyword">class</span>);<br>        //第二种，Mapper接口方式的调用，推荐这种使用方式。<br>        PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        List&lt;<span class="hljs-keyword">User</span>&gt; list = mapper.getUserInfo();<br>        //用PageInfo将包装起来<br>        PageInfo page = <span class="hljs-built_in">new</span> PageInfo(list);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">User</span> map: list)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;page:---&quot;+page);<br>        <span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>    &#125;<br><br><br>### 总结<br>实用的还是PageHelper，他也是物理分页。<br>但在一些项目中也运用mapp接口方式：<br>```//第二种，Mapper接口方式的调用，推荐这种使用方式。<br>PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>List&lt;<span class="hljs-keyword">User</span>&gt; list = userMapper.selectIf(<span class="hljs-number">1</span>);<br><br>//第三种，Mapper接口方式的调用，推荐这种使用方式。<br>PageHelper.offsetPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>List&lt;<span class="hljs-keyword">User</span>&gt; list = userMapper.selectIf(<span class="hljs-number">1</span>);<br><br>//第四种，参数方法调用<br>//存在以下 Mapper 接口方法，你不需要在 <span class="hljs-type">xml</span> 处理后两个参数<br><span class="hljs-built_in">public</span> interface CountryMapper &#123;<br>    List&lt;<span class="hljs-keyword">User</span>&gt; selectByPageNumSize(<br>            @Param(&quot;user&quot;) <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>,<br>            @Param(&quot;pageNum&quot;) <span class="hljs-type">int</span> pageNum, <br>            @Param(&quot;pageSize&quot;) <span class="hljs-type">int</span> pageSize);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis延迟队列</title>
    <link href="/61011741.github.io/2021/10/17/blog11/"/>
    <url>/61011741.github.io/2021/10/17/blog11/</url>
    
    <content type="html"><![CDATA[<p>首先看下以下两种业务情况：</p><ul><li>如果有订单一直处于未支付状态时，如何及时的关闭订单，并且退还库存？</li><li>创建新店铺时，很多天未上传商品，系统如何知道该情况，并发送激活短信？<h4 id="上述场景最简单直接的解决方案是定时扫表。我们假设-30分钟未支付则关闭订单、定时任务设置为-5-分钟一次，那么一个订单最晚会在-30分钟关闭。高达-5-分钟的误差是业务难以接受的。另一方面频繁的扫表可能消耗过多数据库资源，影响线上交易吞吐量。还有人使用-Redis-的过期通知、时间轮、Java-的-DelayQueue-等方式实现延时任务。但他们有缺陷：比如使用-Redis-过期通知不保证准时、发送即忘不保证送达，时间轮缺乏持久化机制容易丢失等。"><a href="#上述场景最简单直接的解决方案是定时扫表。我们假设-30分钟未支付则关闭订单、定时任务设置为-5-分钟一次，那么一个订单最晚会在-30分钟关闭。高达-5-分钟的误差是业务难以接受的。另一方面频繁的扫表可能消耗过多数据库资源，影响线上交易吞吐量。还有人使用-Redis-的过期通知、时间轮、Java-的-DelayQueue-等方式实现延时任务。但他们有缺陷：比如使用-Redis-过期通知不保证准时、发送即忘不保证送达，时间轮缺乏持久化机制容易丢失等。" class="headerlink" title="上述场景最简单直接的解决方案是定时扫表。我们假设 30分钟未支付则关闭订单、定时任务设置为 5 分钟一次，那么一个订单最晚会在 30分钟关闭。高达 5 分钟的误差是业务难以接受的。另一方面频繁的扫表可能消耗过多数据库资源，影响线上交易吞吐量。还有人使用 Redis 的过期通知、时间轮、Java 的 DelayQueue 等方式实现延时任务。但他们有缺陷：比如使用 Redis 过期通知不保证准时、发送即忘不保证送达，时间轮缺乏持久化机制容易丢失等。"></a>上述场景最简单直接的解决方案是定时扫表。我们假设 30分钟未支付则关闭订单、定时任务设置为 5 分钟一次，那么一个订单最晚会在 30分钟关闭。高达 5 分钟的误差是业务难以接受的。另一方面频繁的扫表可能消耗过多数据库资源，影响线上交易吞吐量。还有人使用 Redis 的过期通知、时间轮、Java 的 DelayQueue 等方式实现延时任务。但他们有缺陷：比如使用 Redis 过期通知不保证准时、发送即忘不保证送达，时间轮缺乏持久化机制容易丢失等。</h4><h2 id="所以有必要做个rdis延迟队列，延迟队列得满足以下几个条件："><a href="#所以有必要做个rdis延迟队列，延迟队列得满足以下几个条件：" class="headerlink" title="所以有必要做个rdis延迟队列，延迟队列得满足以下几个条件："></a>所以有必要做个rdis延迟队列，延迟队列得满足以下几个条件：</h2><ul><li>定时尽量精确</li><li>确认重试机制: 任务处理失败或超时应该有重试</li><li>持久化: 服务重启或崩溃不能丢失任务</li></ul></li></ul><p>其实可以用RocketMQ，Kafka等专业消息队列的延时投递功能,不过引入新的中间件通常存在各种非技术方面的麻烦。Redis 作为广泛使用的中间件，何不用 Redis 来制作延时队列呢？</p><p>除了基本的延时投递之外我们的消息队列具有下列优势：</p><ul><li><p>提供 ACK 和重试机制</p></li><li><p>只需要 Redis 和消费者即可运行，无需其它组件</p></li><li><p>提供 At-Least-One 投递语义、并保证消息不会并发消费</p></li></ul><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><blockquote><p>注册处理消息的回调函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-title function_">import</span> <span class="hljs-params">(</span><br><span class="hljs-params"> <span class="hljs-string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="hljs-params"> <span class="hljs-string">&quot;github.com/hdt3213/delayqueue&quot;</span></span><br><span class="hljs-params"> <span class="hljs-string">&quot;strconv&quot;</span></span><br><span class="hljs-params"> <span class="hljs-string">&quot;time&quot;</span></span><br><span class="hljs-params">)</span><br> <br>func <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br> redisCli := redis.NewClient(&amp;redis.Options&#123;<br>  Addr: <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>,<br> &#125;)<br> queue := delayqueue.NewQueue(<span class="hljs-string">&quot;example-queue&quot;</span>, redisCli, func(payload string) bool &#123;<br>  <span class="hljs-comment">// 注册处理消息的回调函数</span><br>        <span class="hljs-comment">// 返回 true 表示已成功消费，返回 false 消息队列会重新投递次消息</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;)<br> <span class="hljs-comment">// 发送延时消息</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>  err := queue.SendDelayMsg(strconv.Itoa(i), time.Hour, delayqueue.WithRetryCount(<span class="hljs-number">3</span>))<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   panic(err)<br>  &#125;<br> &#125;<br> <br> <span class="hljs-comment">// 启动消费协程</span><br> done := queue.StartConsume()<br> <span class="hljs-comment">// 阻塞等待消费协程退出</span><br> &lt;-done<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用pending2ReadyScript 扫描消息ID并把它们移动到 ready 中:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">-- keys: pendingKey, readyKey<br>-- argv: currentTime<br><span class="hljs-type">local</span> <span class="hljs-variable">msgs</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;ZRangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;0&#x27;</span>, ARGV[<span class="hljs-number">1</span>])  -- 从 pending key 中找出已到投递时间的消息<br><span class="hljs-keyword">if</span> (#msgs == <span class="hljs-number">0</span>) then <span class="hljs-keyword">return</span> end<br><span class="hljs-type">local</span> <span class="hljs-variable">args2</span> <span class="hljs-operator">=</span> &#123;<span class="hljs-string">&#x27;LPush&#x27;</span>, KEYS[<span class="hljs-number">2</span>]&#125; -- 将他们放入 ready key 中<br><span class="hljs-keyword">for</span> _,v in <span class="hljs-title function_">ipairs</span><span class="hljs-params">(msgs)</span> <span class="hljs-keyword">do</span><br> table.insert(args2, v) <br>end<br>redis.call(unpack(args2))<br>redis.call(<span class="hljs-string">&#x27;ZRemRangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;0&#x27;</span>, ARGV[<span class="hljs-number">1</span>])  -- 从 pending key 中删除已投递的消息<br></code></pre></td></tr></table></figure><blockquote><p>ready2UnackScript 从 ready 中取出一条消息发送给消费者并放入 unack 中</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- keys: readyKey/retryKey, unackKey</span><br><span class="hljs-comment">-- argv: retryTime</span><br><span class="hljs-keyword">local</span> msg = redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;RPop&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> msg) <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;ZAdd&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">1</span>], msg)<br><span class="hljs-keyword">return</span> msg<br></code></pre></td></tr></table></figure><blockquote><p>unack2RetryScript 从 retry 中找出所有已到重试时间的消息并把它们移动到 unack 中：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">-- keys: unackKey, retryCountKey, retryKey, garbageKey<br>-- argv: currentTime<br><span class="hljs-type">local</span> <span class="hljs-variable">msgs</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;ZRangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;0&#x27;</span>, ARGV[<span class="hljs-number">1</span>])  -- 找到已到重试时间的消息<br><span class="hljs-keyword">if</span> (#msgs == <span class="hljs-number">0</span>) then <span class="hljs-keyword">return</span> end<br><span class="hljs-type">local</span> <span class="hljs-variable">retryCounts</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;HMGet&#x27;</span>, KEYS[<span class="hljs-number">2</span>], unpack(msgs)) -- 查询剩余重试次数<br><span class="hljs-keyword">for</span> i,v in <span class="hljs-title function_">ipairs</span><span class="hljs-params">(retryCounts)</span> <span class="hljs-keyword">do</span><br> <span class="hljs-type">local</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> msgs[i]<br> <span class="hljs-keyword">if</span> <span class="hljs-title function_">tonumber</span><span class="hljs-params">(v)</span> &gt; <span class="hljs-number">0</span> then -- 剩余次数大于 <span class="hljs-number">0</span><br>  redis.call(<span class="hljs-string">&quot;HIncrBy&quot;</span>, KEYS[<span class="hljs-number">2</span>], k, -<span class="hljs-number">1</span>) -- 减少剩余重试次数<br>  redis.call(<span class="hljs-string">&quot;LPush&quot;</span>, KEYS[<span class="hljs-number">3</span>], k) -- 添加到 retry key 中<br> <span class="hljs-keyword">else</span> -- 剩余重试次数为 <span class="hljs-number">0</span><br>  redis.call(<span class="hljs-string">&quot;HDel&quot;</span>, KEYS[<span class="hljs-number">2</span>], k) -- 删除重试次数记录<br>  redis.call(<span class="hljs-string">&quot;SAdd&quot;</span>, KEYS[<span class="hljs-number">4</span>], k) -- 添加到垃圾桶，等待后续删除<br> end<br>end<br>redis.call(<span class="hljs-string">&#x27;ZRemRangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;0&#x27;</span>, ARGV[<span class="hljs-number">1</span>])  -- 将已处理的消息从 unack key 中删除<br></code></pre></td></tr></table></figure><blockquote><p>ack处理信息的删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">func (q *DelayQueue) ack(idStr string) error &#123;<br> ctx := context.Background()<br> err := q.redisCli.ZRem(ctx, q.unAckKey, idStr).Err()<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;remove from unack failed: %v&quot;</span>, err)<br> &#125;<br> <span class="hljs-comment">// msg key has ttl, ignore result of delete</span><br> _ = q.redisCli.Del(ctx, q.genMsgKey(idStr)).Err()<br> q.redisCli.HDel(ctx, q.retryCountKey, idStr)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>消息队列的核心就是每秒执行一次的 consume 函数，它负责调用上述脚本将消息转移到正确的集合中并回调 consumer 来消费消息。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">func (q *DelayQueue) consume() error &#123;<br> <span class="hljs-comment">// 执行 pending2ready，将已到时间的消息转移到 ready</span><br> err := q.pending2Ready()<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> err<br> &#125;<br> <span class="hljs-comment">// 循环调用 ready2Unack 拉取消息进行消费</span><br> <span class="hljs-keyword">var</span> fetchCount uint<br> <span class="hljs-keyword">for</span> &#123;<br>  idStr, err := q.ready2Unack()<br>  <span class="hljs-keyword">if</span> err == redis.Nil &#123; <span class="hljs-comment">// consumed all</span><br>   <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  fetchCount++<br>  ack, err := q.callback(idStr)<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">if</span> ack &#123;<br>   err = q.ack(idStr)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   err = q.nack(idStr)<br>  &#125;<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">if</span> fetchCount &gt;= q.fetchLimit &#123;<br>   <span class="hljs-keyword">break</span><br>  &#125;<br> &#125;<br> <span class="hljs-comment">// 将 nack 或超时的消息放入重试队列</span><br> err = q.unack2Retry()<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> err<br> &#125;<br>    <span class="hljs-comment">// 清理已达到最大重试次数的消息</span><br> err = q.garbageCollect()<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> err<br> &#125;<br> <span class="hljs-comment">// 消费重试队列</span><br> fetchCount = <span class="hljs-number">0</span><br> <span class="hljs-keyword">for</span> &#123;<br>  idStr, err := q.retry2Unack()<br>  <span class="hljs-keyword">if</span> err == redis.Nil &#123; <span class="hljs-comment">// consumed all</span><br>   <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  fetchCount++<br>  ack, err := q.callback(idStr)<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">if</span> ack &#123;<br>   err = q.ack(idStr)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   err = q.nack(idStr)<br>  &#125;<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">if</span> fetchCount &gt;= q.fetchLimit &#123;<br>   <span class="hljs-keyword">break</span><br>  &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud +jwt 鉴权网关</title>
    <link href="/61011741.github.io/2021/08/17/blog9/"/>
    <url>/61011741.github.io/2021/08/17/blog9/</url>
    
    <content type="html"><![CDATA[<h2 id="如今的项目微服务繁多复杂，如果每个微服务都要自己去写一个鉴权，那么代码冗余度非常高，所以我们一般把鉴权操作放到网关Gateway中。"><a href="#如今的项目微服务繁多复杂，如果每个微服务都要自己去写一个鉴权，那么代码冗余度非常高，所以我们一般把鉴权操作放到网关Gateway中。" class="headerlink" title="如今的项目微服务繁多复杂，如果每个微服务都要自己去写一个鉴权，那么代码冗余度非常高，所以我们一般把鉴权操作放到网关Gateway中。"></a>如今的项目微服务繁多复杂，如果每个微服务都要自己去写一个鉴权，那么代码冗余度非常高，所以我们一般把鉴权操作放到网关Gateway中。</h2><ul><li>在网关完成url的鉴权（一切的OPTION的请求全部放行，一切不存在的请求都拒绝访问）</li><li>将解析后的jwt token当做请求头传递到下游服务中</li><li>整合Spring Security Oauth2 Resource Server</li></ul><p><strong>前期需要搭建认证服务器以及使用Spring Security Oauth2 Resource Server资源服务器。</strong> </p><blockquote><p>网关导入相关jar包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-resource-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义授权管理器</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs haxe"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义授权管理器，判断用户是否有权限访问</span><br><span class="hljs-comment"> */</span><br>@Component<br>@Slf4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomReactiveAuthorizationManager</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ReactiveAuthorizationManager</span></span>&lt;<span class="hljs-title">AuthorizationContext</span>&gt; </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此处保存的是资源对应的权限，可以从数据库中获取</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Map&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; AUTH_MAP = Maps.<span class="hljs-keyword">new</span><span class="hljs-type">ConcurrentMap</span>();<br> <br>    @PostConstruct<br>    <span class="hljs-keyword">public</span> void initAuthMap() &#123;<br>        AUTH_MAP.put(<span class="hljs-string">&quot;/user/findAllUsers&quot;</span>, <span class="hljs-string">&quot;user.userInfo&quot;</span>);<br>        AUTH_MAP.put(<span class="hljs-string">&quot;/user/addUser&quot;</span>, <span class="hljs-string">&quot;ROLE_ADMIN&quot;</span>);<br>    &#125;<br> <br> <br>    @Override<br>    <span class="hljs-keyword">public</span> Mono&lt;AuthorizationDecision&gt; check(Mono&lt;Authentication&gt; authentication, AuthorizationContext authorizationContext) &#123;<br>        ServerWebExchange exchange = authorizationContext.getExchange();<br>        ServerHttpRequest request = exchange.getRequest();<br>        <span class="hljs-keyword">String</span> path = request.getURI().getPath();<br> <br>        <span class="hljs-comment">// 带通配符的可以使用这个进行匹配</span><br>        PathMatcher pathMatcher = <span class="hljs-keyword">new</span> <span class="hljs-type">AntPathMatcher</span>();<br>        <span class="hljs-keyword">String</span> authorities = AUTH_MAP.<span class="hljs-keyword">get</span>(path);<br>        log.info(<span class="hljs-string">&quot;访问路径:[&#123;&#125;],所需要的权限是:[&#123;&#125;]&quot;</span>, path, authorities);<br> <br>        <span class="hljs-comment">// option 请求，全部放行</span><br>        <span class="hljs-keyword">if</span> (request.getMethod() == HttpMethod.OPTIONS) &#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> <span class="hljs-type">AuthorizationDecision</span>(<span class="hljs-literal">true</span>));<br>        &#125;<br> <br>        <span class="hljs-comment">// 不在权限范围内的url，全部拒绝</span><br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(authorities)) &#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> <span class="hljs-type">AuthorizationDecision</span>(<span class="hljs-literal">false</span>));<br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> authentication<br>                .filter(Authentication:<span class="hljs-type"></span>:isAuthenticated)<br>                .filter(a -&gt; a instanceof JwtAuthenticationToken)<br>                .<span class="hljs-keyword">cast</span>(JwtAuthenticationToken.class)<br>                .doOnNext(token -&gt; &#123;<br>                    System.out.println(token.getToken().getHeaders());<br>                    System.out.println(token.getTokenAttributes());<br>                &#125;)<br>                .flatMapIterable(AbstractAuthenticationToken:<span class="hljs-type"></span>:getAuthorities)<br>                .map(GrantedAuthority:<span class="hljs-type"></span>:getAuthority)<br>                .any(authority -&gt; Objects.equals(authority, authorities))<br>                .map(AuthorizationDecision:<span class="hljs-type"></span>:<span class="hljs-keyword">new</span><span class="hljs-type"></span>)<br>                .defaultIfEmpty(<span class="hljs-keyword">new</span> <span class="hljs-type">AuthorizationDecision</span>(<span class="hljs-literal">false</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>处理token异常</p></blockquote> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 认证失败异常处理</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomServerAuthenticationEntryPoint</span> implements ServerAuthenticationEntryPoint &#123;<br>    @Override<br>    public Mono&lt;Void&gt; commence(ServerWebExchange exchange, AuthenticationException ex) &#123;<br> <br>        <span class="hljs-keyword">return</span> Mono.defer<span class="hljs-function"><span class="hljs-params">(() -&gt; Mono.just(exchange.getResponse()))</span></span><br><span class="hljs-function">                .<span class="hljs-title">flatMap</span><span class="hljs-params">(response -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-built_in">String</span> body = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:401,\&quot;msg\&quot;:\&quot;token不合法或过期\&quot;&#125;&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                    DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer))</span></span><br><span class="hljs-params"><span class="hljs-function">                            .doOnError(error -&gt; DataBufferUtils.release(buffer));</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>当用户没有权限时：</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomServerAccessDeniedHandler</span> <span class="hljs-title class_">implements</span> <span class="hljs-title class_">ServerAccessDeniedHandler</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Mono</span>&lt;<span class="hljs-type">Void</span>&gt; handle(<span class="hljs-type">ServerWebExchange</span> exchange, <span class="hljs-type">AccessDeniedException</span> denied) &#123;<br> <br>        <span class="hljs-type">ServerHttpRequest</span> request <span class="hljs-operator">=</span> exchange.getRequest();<br> <br>        <span class="hljs-keyword">return</span> exchange.getPrincipal()<br>                .doOnNext(principal -&gt; log.info(<span class="hljs-string">&quot;用户:[&#123;&#125;]没有访问:[&#123;&#125;]的权限.&quot;</span>, principal.getName(), request.getURI()))<br>                .flatMap(principal -&gt; &#123;<br>                    <span class="hljs-type">ServerHttpResponse</span> response <span class="hljs-operator">=</span> exchange.getResponse();<br>                    response.setStatusCode(<span class="hljs-type">HttpStatus</span>.<span class="hljs-type">FORBIDDEN</span>);<br>                    <span class="hljs-type">String</span> body <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-subst">\&quot;</span>code<span class="hljs-subst">\&quot;</span>:403,<span class="hljs-subst">\&quot;</span>msg<span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\&quot;</span>您无权限访问<span class="hljs-subst">\&quot;</span>&#125;&quot;</span>;<br>                    <span class="hljs-type">DataBuffer</span> buffer <span class="hljs-operator">=</span> response.bufferFactory().wrap(body.getBytes(<span class="hljs-type">StandardCharsets</span>.<span class="hljs-type">UTF_8</span>));<br>                    <span class="hljs-keyword">return</span> response.writeWith(<span class="hljs-type">Mono</span>.just(buffer))<br>                            .doOnError(error -&gt; <span class="hljs-type">DataBufferUtils</span>.release(buffer));<br>                &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p> 将token传递到下游服务器</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenTransferFilter</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">WebFilter</span></span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final ObjectMapper OBJECT_MAPPER = <span class="hljs-keyword">new</span> <span class="hljs-type">ObjectMapper</span>();<br><br>   <span class="hljs-keyword">static</span> &#123;<br>       OBJECT_MAPPER.registerModule(<span class="hljs-keyword">new</span> <span class="hljs-type">Jdk8Module</span>());<br>       OBJECT_MAPPER.registerModule(<span class="hljs-keyword">new</span> <span class="hljs-type">JavaTimeModule</span>());<br>   &#125;<br><br>   @Override<br>   <span class="hljs-keyword">public</span> Mono&lt;<span class="hljs-keyword">Void</span>&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;<br>       <span class="hljs-keyword">return</span> ReactiveSecurityContextHolder.getContext()<br>               .map(SecurityContext:<span class="hljs-type"></span>:getAuthentication)<br>               .<span class="hljs-keyword">cast</span>(JwtAuthenticationToken.class)<br>               .flatMap(authentication -&gt; &#123;<br>                   ServerHttpRequest request = exchange.getRequest();<br>                   request = request.mutate()<br>                           .header(<span class="hljs-string">&quot;tokenInfo&quot;</span>, toJson(authentication.getPrincipal()))<br>                           .build();<br><br>                   ServerWebExchange <span class="hljs-keyword">new</span><span class="hljs-type">Exchange</span> = exchange.mutate().request(request).build();<br><br>                   <span class="hljs-keyword">return</span> chain.filter(<span class="hljs-keyword">new</span><span class="hljs-type">Exchange</span>);<br>               &#125;);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> toJson(Object obj) &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> OBJECT_MAPPER.writeValueAsString(obj);<br>       &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置Yml</p></blockquote><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">application</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">gateway-auth</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">nacos</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">discovery</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">server-addr</span><span class="hljs-punctuation">:</span> <span class="hljs-string">localhost:8847</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: user-provider</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lb://user-provider</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SPringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis淘汰机制</title>
    <link href="/61011741.github.io/2021/08/15/blog10/"/>
    <url>/61011741.github.io/2021/08/15/blog10/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总所周知，redis是个基于内存的缓存数据库，那再内存没有空间存入新的空间的时候，redis是怎么处理的呢？</p></blockquote><ul><li>答案是此时的redis会执行一些淘汰的策略，把一些垃圾数据给淘汰掉，腾出新的空间。<h2 id="redis6种淘汰策略"><a href="#redis6种淘汰策略" class="headerlink" title="redis6种淘汰策略"></a>redis6种淘汰策略</h2></li></ul><p>1.noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</p><p>2.allkeys-lru：从所有key中使用LRU算法进行淘汰（LRU算法：即最近最少使用算法）</p><p>3.volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</p><p>4.allkeys-random：从所有key中随机淘汰数据</p><p>5.volatile-random：从设置了过期时间的key中随机淘汰</p><p>6.volatile-ttl：在设置了过期时间的key中，淘汰过期时间剩余最短的</p><p>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误</p><blockquote><p>查看当前的淘汰策略：config get maxmemory-policy</p><p>设置淘汰策略：1. maxmemory-policy allkeys-lru（修改redis.conf文件）<br>2.命令修改 config set maxmemory-policy allkeys-lru</p><p>获取redis能使用的最大内存 config get maxmemory</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DocKer搭建本地开发环境</title>
    <link href="/61011741.github.io/2021/05/15/blog8/"/>
    <url>/61011741.github.io/2021/05/15/blog8/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>Docker简单来说就是一个开源的应用容器引擎，可以让程序开发人员打包应用及依赖包到一个可移植的容器中，再发布到Linux的机器上，也可以实现虚拟化。简而言之，就是一个便捷的应用容器。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><ul><li>在mac平台下，去下载一个dmg的安装文件。下载好了之后，双击，然后拖入就可以了，windows应该也是类似的。<br>链接如下：<blockquote><p><a href="https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=">https://hub.docker.com/search/?type=edition&amp;offering=community&amp;q=</a></p></blockquote></li></ul><p>查看docker 版本信息，如果出现版本信息则表示安装成功。</p><ul><li><p> 安装docker-composer<br>链接如下：</p><blockquote><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p></blockquote></li><li><p>安装完成后输入命令检查</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">  ➜  ~ docker-compose <span class="hljs-keyword">version</span><br>docker-compose <span class="hljs-keyword">version</span> <span class="hljs-number">1.23</span>.<span class="hljs-number">2</span>, build <span class="hljs-number">1110</span>ad01<br>docker-<span class="hljs-keyword">py</span> <span class="hljs-keyword">version</span>: <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span><br>CPython <span class="hljs-keyword">version</span>: <span class="hljs-number">3.6</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li><li><p>下载laradock到本地</p><blockquote><p><a href="https://github.com/laradock/laradock">https://github.com/laradock/laradock</a> </p></blockquote></li><li><p>配置env文件<br>cp env- example env,看需求修改远程映射路径。</p></li><li><p>执行命令 docker-compose up -d nginx mysql 运行</p><p>配置项目信息：<br>DB_CONNECTION=mysql<br>DB_HOST=mysql<br>DB_PORT=3306<br>DB_DATABASE=blog<br>DB_USERNAME=root<br>DB_PASSWORD=tl123456</p></li></ul><p><strong>注意，数据库主机必须得是别名</strong></p><ul><li>配置宿主机的 host vim /etc/hosts（可以加入自己设置的虚拟域名）</li></ul><p> 访问：url<br> 结果：<br> <img src="https://img-blog.csdnimg.cn/img_convert/9290221335b6c57c20060d578f40118c.jpeg" alt="图片显示"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单聊一聊单例模式</title>
    <link href="/61011741.github.io/2020/11/08/blog6/"/>
    <url>/61011741.github.io/2020/11/08/blog6/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式介绍："><a href="#单例模式介绍：" class="headerlink" title="单例模式介绍："></a>单例模式介绍：</h2><blockquote><p>单例模式的使用： 单例模式，顾名思义，要保证程序中只有这么一个单例，保证仅有一个实例。比如发号器，redis连接对象等</p></blockquote><blockquote><p>单例模式的分类：1.懒汉模式：简单来说就是懒加载，等到程序需要这个对象的时候再来创建，延迟创建对象。 2.饿汉：提前创建好对象，类加载就会导致该单实例对象被创建。</p></blockquote><blockquote><p>单例模式的实现步骤：<br>1.私有化构造函数，例必须是一个且唯一，并且必须加上static属性。2.提供获取单例的方法</p></blockquote><p>示例： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 单例设计模式-懒汉式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-comment">// 当需要用到该实例的时候再创建实例对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有化</span><br><span class="hljs-comment">     * 不能通过 new SingletonLazy() 的方式创建实例</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 当需要用到该实例的时候在加载</span><br><span class="hljs-comment">     * 只能通过 SingletonLazy.getInstance() 这种方式获取实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例对象的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法实例化成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一：</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 对外暴露一个方法获取该类的对象</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 缺点：线程不安全，多线程下存在安全问题</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 实例为null时候才创建</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 线程安全问题：</span><br><span class="hljs-comment">             * 当某一时刻，两个或多个线程同时判断到instance == null成立的时候</span><br><span class="hljs-comment">             * 这些线程同时进入该if判断内部执行实例化</span><br><span class="hljs-comment">             * 则会新建出不止一个SingletonLazy实例</span><br><span class="hljs-comment">             */</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<span class="hljs-comment">// 当需要的时候再进行实例化对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式二：</span><br><span class="hljs-comment">     * 通过加synchronized锁 保证线程安全</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 采用synchronized 对方法加锁有很大的性能开销</span><br><span class="hljs-comment">     * 因为当getInstance2()内部逻辑比较复杂的时候，在高并发条件下</span><br><span class="hljs-comment">     * 没获取到加锁方法执行权的线程，都得等到这个方法内的复杂逻辑执行完后才能执行，等待浪费时间，效率比较低</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonLazy <span class="hljs-title function_">getInstance2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 实例为null时候才创建</span><br>            <span class="hljs-comment">// 方法上加synchronized锁后可以保证线程安全</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<span class="hljs-comment">// 当需要的时候再进行实例化对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式三：</span><br><span class="hljs-comment">     * 在getInstance3()方法内，针对局部需要加锁的代码块加锁，而不是给整个方法加锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 也存在缺陷：</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 实例为null时候才创建</span><br>            <span class="hljs-comment">// 局部加锁后可以保证线程安全,效率较高</span><br>            <span class="hljs-comment">// 缺陷：假设线程A和线程B</span><br>            <span class="hljs-keyword">synchronized</span> (SingletonLazy.class)&#123;<br>                <span class="hljs-comment">// 当线程A获得锁的执行权的时候B等待 A执行new SingletonLazy();实例化</span><br>                <span class="hljs-comment">// 当A线程执行完毕后，B再获得执行权，这时候还是可以实例化该对象</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<span class="hljs-comment">// 当需要的时候再进行实例化对象</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析上述代码，可以发现方法3存在不足之处，我们可以对代码进行优化"><a href="#分析上述代码，可以发现方法3存在不足之处，我们可以对代码进行优化" class="headerlink" title="分析上述代码，可以发现方法3存在不足之处，我们可以对代码进行优化:"></a>分析上述代码，可以发现方法3存在不足之处，我们可以对代码进行优化:</h3><ul><li>在getInstance3()方法内，针对局部需要加锁的代码块加锁，而不是给整个方法加锁</li><li>DCL 双重检查锁定 (Double-Checked-Locking) 在多线程情况下保持高性</li><li>这是否安全？ instance = new SingletonLazy(); 并不是原子性操作</li><li>jvm中 instance实例化内存模型流程如下：</li><li>1.分配空间给对象</li><li>2.在空间内创建对象</li><li>3.将对象赋值给instance引用</li><li>假如出现如下顺序错乱的情况：</li><li>线程的执行顺序为：1 -&gt; 3 -&gt; 2, 那么这时候会把值写回主内存</li><li>则，其他线程就会读取到instance的最新值,但是这个是不完全的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance3plus</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 实例为null时候才创建</span><br>        <span class="hljs-comment">// 局部加锁后可以保证线程安全,效率较高</span><br>        <span class="hljs-comment">// 假设线程A和线程B </span><br>        <span class="hljs-keyword">synchronized</span> (SingletonLazy.class)&#123;<span class="hljs-comment">// 第一重检查</span><br>            <span class="hljs-comment">// 当线程A获得锁的执行权的时候B等待 A执行new SingletonLazy();实例化</span><br>            <span class="hljs-comment">// 当A线程执行完毕后，B再获得执行权，这时候再判断instance == null是否成立</span><br>            <span class="hljs-comment">// 如果不成立，B线程无法 实例化SingletonLazy</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">// 第二重检查</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<span class="hljs-comment">// 当需要的时候再进行实例化对象</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 单例设计模式-饿汉式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHungry</span> &#123;<br><br>    <span class="hljs-comment">// 当类加载的时候就直接实例化对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonHungry</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonHungry</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonHungry</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例对象的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法实例化成功！&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 饿汉创建的优点：不需要考虑线程安全的问题，实现比较简单</span><br><span class="hljs-comment">     * 缺点：instance对象一直占用内存，耗费内存</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonHungry <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<span class="hljs-comment">// 当类加载的时候就直接实例化对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>个人觉得对象空间占用较小，创建简单的情况下用饿汉，其他的时候用懒汉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java 设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud注册中心 Eureka常用的注解</title>
    <link href="/61011741.github.io/2020/10/25/Blog5/"/>
    <url>/61011741.github.io/2020/10/25/Blog5/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Eureka"><a href="#什么是Eureka" class="headerlink" title="什么是Eureka"></a>什么是Eureka</h2><p>Eureka是SpringCloud的核心模块之一，Eureka是一个基于RestFul的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对与微服务来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类十余Dubbo的注册中心，比如Zookeepe. </p><h2 id="Eureka的相关注解："><a href="#Eureka的相关注解：" class="headerlink" title="Eureka的相关注解："></a>Eureka的相关注解：</h2><ul><li>@EnableEurekaClient</li><li>@EnableDiscoveryClient<br>两个注解的异同及使用场景如下：<br>@EnableDiscoveryClient和@EnableEurekaClient<br>表示开启eureka客服端，都是能够让注册中心能够发现，扫描到改服务。<br>上面两个注解都是用在应用的启动类上面，声明这是一个Eureka Client ，现在说明两个注解的区别。<br>不同之处就是  @EnableEurekaClient 只适用于Eureka作为注册中心，而@EnableDiscoveryClient 可以是其他注册中心。</li></ul><p>用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 服务注册发现</span><br><span class="hljs-comment">// @EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="EnableEurekaServer"><a href="#EnableEurekaServer" class="headerlink" title="@EnableEurekaServer"></a>@EnableEurekaServer</h2><p>开启eureka注册中心，为eureka server服务端， 可以接受其他的服务注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">// 开启 eureka server 服务端，接受别人注册</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java SpinrgCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot的@RequestParam @RequestBody @PathVariable 等参数绑定注解</title>
    <link href="/61011741.github.io/2020/10/15/blog4/"/>
    <url>/61011741.github.io/2020/10/15/blog4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-PathVariable"><a href="#1-PathVariable" class="headerlink" title="1: @PathVariable"></a>1: @PathVariable</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/&#123;userId&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String userId, Model model)</span> &#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中将REquest url中的变量userID的值绑定到了方法的参数上。即使用 <strong>@PathVariable</strong>注解时可以将{*}的值绑定到方法的参数上</p><h1 id="2：-RequestBody"><a href="#2：-RequestBody" class="headerlink" title="2：@RequestBody"></a>2：@RequestBody</h1><p>@RequestBody接收的参数是来自RequestBody中，即请求体。<br>@RequestBody一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。 <strong>@RequestBody</strong> 接受的是一个Json格式的字符串，一定是一个字符串。<br>我们写一个User类 定义一下成员变量：</p><blockquote><ul><li>String userName</li><li>String password<br>@requestBody User user 这种形式会将JSON字符串中的值赋予user中对应的属性上。需要注意的是，JSON字符串中的key必须对应user中的属性名，否则是请求不过去的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@requestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@requestBody</span> User user)</span>&#123;<br>　　System.out.println(user.getUserName()+<span class="hljs-string">&quot; ：&quot;</span>+user.getPwd());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-RequestParam"><a href="#3-RequestParam" class="headerlink" title="3: @RequestParam"></a>3: @RequestParam</h1><p>该注解<br>@RequestParam 三个常用属性：</p><p>（1）value：浏览器请求传入的参数名，默认会将后面的方法参数名称作为接收的参数名。<br>（2）required：是否必需，默认为 true，即请求中必须包含该参数，如果没有包含，将会抛出异常（可选配置）<br>（3）defaultValue：当没有传入参数时，则使用此默认值。如果设置了该值，required 将自动设为 false，无论是否配置了required，配置了什么值，都是 false（可选配置）</p>]]></content>
    
    
    
    <tags>
      
      <tag>java SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Autowired 和@Resource 新理解</title>
    <link href="/61011741.github.io/2020/09/08/blog7/"/>
    <url>/61011741.github.io/2020/09/08/blog7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天偶然写代码的时候，看见项目中有waring的提示，如下：</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Autowire</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate; <br></code></pre></td></tr></table></figure><p>提示的警告信息：<br>“Field injection is not recommended Inspection info: Spring Team recommends: “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.<br>大概意思为注入方式不推荐。</p><p>其实注入方式就几种：</p><ul><li>基于Setter的依赖注入<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">UserServiceImpl</span> <span class="hljs-symbol">implents</span> <span class="hljs-symbol">UserService</span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    @Autowire<br>    <span class="hljs-keyword">public</span> serUserDao(UserDao userDao)&#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>基于构造函数的依赖注入<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">UserServiceImpl</span> <span class="hljs-symbol">implents</span> <span class="hljs-symbol">UserService</span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    @Autowire<br>    <span class="hljs-keyword">public</span> UserServiceImpl(UserDao userDao)&#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>基于字段的依赖注入<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">UserServiceImpl</span> <span class="hljs-symbol">implents</span> <span class="hljs-symbol">UserService</span>&#123;<br>    @Autowire<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们在开发中基本上是用字段依赖注入，因为简便明了。但其实这样用不好，sping不建议。<br>Field注入的缺点</p></blockquote></li><li>不能像构造器那样注入不可变的对象</li><li>依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</li><li>会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</li><li>依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则</li></ul><blockquote><p>@Autowired VS @Resource<br>事实上，他们的基本功能都是通过注解实现依赖注入，只不过@Autowired是Spring定义的，而@Resource是JSR-250定义的。大致功能基本相同，但是还有一些细节不同：</p></blockquote><blockquote><p>依赖识别方式：@Autowired默认是byType可以使用@Qualifier指定Name，@Resource默认ByName如果找不到则ByType<br>适用对象：@Autowired可以对构造器、方法、参数、字段使用，@Resource只能对方法、字段使用<br>提供方：@Autowired是Spring提供的，@Resource是JSR-250提供的<br>各种DI方式的优缺点<br>参考Spring官方文档，建议了如下的使用场景：</p></blockquote><blockquote><p>构造函数注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）<br>Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）<br>Field注入：大多数情况下尽量少使用字段注入，一定要使用的话，@Resource相对@Autowired对IoC容器的耦合更低</p></blockquote><p>那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？<br>@Autowired是Spring提供的，而@Resource是JSR-250提供的，它是Java标准。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 中的对象</title>
    <link href="/61011741.github.io/2020/09/06/Blog3/"/>
    <url>/61011741.github.io/2020/09/06/Blog3/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-为什么被称作是一个容器？它里面的对象是谁创建的？以及相关属性是由谁设置的？"><a href="#Spring-为什么被称作是一个容器？它里面的对象是谁创建的？以及相关属性是由谁设置的？" class="headerlink" title="Spring 为什么被称作是一个容器？它里面的对象是谁创建的？以及相关属性是由谁设置的？"></a>Spring 为什么被称作是一个容器？它里面的对象是谁创建的？以及相关属性是由谁设置的？</h2><blockquote><p>我们举个例子来简单说明。编写一个Student的实体类：<br> <figure class="highlight plaintext"><figcaption><span>class Student &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs public">   private String name;<br>   public String getName() &#123;<br>       return name;<br>  &#125;<br>   public void setName(String name) &#123;<br>       this.name = name;<br>  &#125;<br>   public void show()&#123;<br>       System.out.println(&quot;Student&#x27;s name is&quot;+ name );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p>编写一个XML的文件<br> <figure class="highlight java"><figcaption><span><?xml version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>      xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>      xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br>   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;<br>   &lt;bean id=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;com.tl.pojo.Student&quot;</span>&gt;<br>       &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;<br>   &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><br>进行相关测试：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs @Test">public void test()&#123;<br>   //解析beans.xml文件 , 生成管理相应的Bean对象<br>   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);//xml的名称为beans<br>   //getBean : 参数即为spring配置文件中bean的id .<br>   Student student = (Student) context.getBean(&quot;student&quot;);<br>   stuent.show();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其实在这个简单的学生类中涉及到了控制和反转。-控制：Studnt不是由程序本身来创建的，而是由Spring通过配置相关的beans。xml文件来控制创建的。-反转：程序由主动的创建对象变成了被动的接收对象。"><a href="#其实在这个简单的学生类中涉及到了控制和反转。-控制：Studnt不是由程序本身来创建的，而是由Spring通过配置相关的beans。xml文件来控制创建的。-反转：程序由主动的创建对象变成了被动的接收对象。" class="headerlink" title="其实在这个简单的学生类中涉及到了控制和反转。 控制：Studnt不是由程序本身来创建的，而是由Spring通过配置相关的beans。xml文件来控制创建的。 反转：程序由主动的创建对象变成了被动的接收对象。"></a>其实在这个简单的学生类中涉及到了控制和反转。 控制：Studnt不是由程序本身来创建的，而是由Spring通过配置相关的beans。xml文件来控制创建的。 反转：程序由主动的创建对象变成了被动的接收对象。</h2><h2 id="IOC创建对象的方式："><a href="#IOC创建对象的方式：" class="headerlink" title="IOC创建对象的方式："></a>IOC创建对象的方式：</h2><blockquote><ul><li>通过无参构造方法来创建</li><li>编写 beans.xml</li><li>测试类 </li></ul></blockquote><figure class="highlight plaintext"><figcaption><span>class User &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs public">   private String name;<br>   public User() &#123;<br>       System.out.println(&quot;无参构造&quot;);<br>  &#125;<br>   public void setName(String name) &#123;<br>       this.name = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在后续编写xml 以及相关测试类 new ClassPathXmlApplicationContext(“beans.xml”)的时候 user已经创建好了</p><h2 id="IOC创建对象的方式：-1"><a href="#IOC创建对象的方式：-1" class="headerlink" title="IOC创建对象的方式："></a>IOC创建对象的方式：</h2><blockquote><ul><li>通过有参构造方法来创建</li><li>编写 beans.xml</li><li>测试类 </li></ul></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br>   private String <span class="hljs-type">name</span>;<br>   <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span>(String <span class="hljs-type">name</span>) &#123;<br>       this.name = <span class="hljs-type">name</span>;<br>  &#125;<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setName(String <span class="hljs-type">name</span>) &#123;<br>       this.name = <span class="hljs-type">name</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在后续编写xml 以及相关测试类 new ClassPathXmlApplicationContext(“beans.xml”)的时候 user也已经创建好了</p><blockquote><p>总结<br>所以说在配置文件加载的时候，对象以及又Spring初始化了。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 笔记</title>
    <link href="/61011741.github.io/2020/07/20/bLog2/"/>
    <url>/61011741.github.io/2020/07/20/bLog2/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-的概述，几个常见的Spring的问题："><a href="#Spring-的概述，几个常见的Spring的问题：" class="headerlink" title="Spring 的概述，几个常见的Spring的问题："></a>Spring 的概述，几个常见的Spring的问题：</h2><blockquote><ul><li>Spring 是什么？</li><li>Spring的两大核心</li><li>Spring的发展历程和优势？</li><li>Spring 是什么？<br>官网解释的非常详细和明了：<br>官方地址： <a href="http://spring.io/">spring</a>  </li></ul></blockquote><h2 id="为什么要用Spring呢？总结了以下有几点优点："><a href="#为什么要用Spring呢？总结了以下有几点优点：" class="headerlink" title="为什么要用Spring呢？总结了以下有几点优点："></a>为什么要用Spring呢？总结了以下有几点优点：</h2><blockquote><ul><li>方便解耦，简化开发</li><li><strong>控制反转 IoC , 面向切面 Aop</strong></li><li>声明事物的支持以及对框架的支持</li><li>方便程序的测试以及继承各种优秀的框架</li></ul></blockquote><h2 id="spring的组成："><a href="#spring的组成：" class="headerlink" title="spring的组成："></a>spring的组成：</h2><p>1.spring由七大模块组成：分别是Spring 核心容器（Spring Core）、应用上下文（Spring Context）、Spring面向切面编程（Spring AOP）、JDBC和DAO模块（Spring DAO）、对象实体映射（Spring ORM）、Web模块（Spring Web）以及MVC模块（SpringWebMVC）。</p><blockquote><ul><li>Spring核心容器：核心容器提供Spring框架开发的一些基本组成。核心容器的主要组件是BeanFactory，它是工厂模式的实现。</li><li>Spring ContextSpring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li>Spring Aop:通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li><li>Spring DAO:DBC、DAO的抽象层，提供了有意义的异常层次结构实现，可用该结构来管理异常处理，和不同数据库提供商抛出的错误信息，异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</li><li>Spring ORM:对象实体映射Spring ， 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map等。</li><li>Spring Web Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li>SpringMVC: MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity等</li></ul></blockquote><blockquote><h2 id="IOC本质："><a href="#IOC本质：" class="headerlink" title="IOC本质："></a>IOC本质：</h2><p>  &gt;-  控制反转是一种通过描述（XML或注解）并通过第三方去生产或产生特定对象的方式，在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入。（Dependency Injection 简称 DI）。OC的实现同样也需要一个过程：<br>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象。</p></blockquote><blockquote><ul><li>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</li></ul></blockquote><blockquote><ul><li>实现完成后，彻底不用在程序中改动了，要实现不同的操作。<br>只需要在XML配置文件中进行修改。</li></ul></blockquote><blockquote><ul><li>所谓IOC，便是：对象由Spring来创建，管理，装配。</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单聊一聊Spring/SpringBuilder/SpringBuffer</title>
    <link href="/61011741.github.io/2020/07/15/blog1/"/>
    <url>/61011741.github.io/2020/07/15/blog1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>1.String 是不可变字符串，每对Spring进行编写后都会产生一个新的字符串对象。<br>2.StringBuffer StringBuilder都是可变的字符串<br>3.StringBuffer StringBuilder在功能以及用法上基本等价。但是StringBuffer中很多办法都用了Synchronized关键字进行修饰，所以线程比较安全，而StringBuilder中并没有用其修饰，所以它不安全，但是在单线程下，它不用每次判断锁，因此效率较高。  </p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p><strong>String</strong> 对象不是一旦创建了就不改变了吗 ？ 那它常用的修改方法的值是怎么样实现的呢？<br>拥有方法如下： substring(int,int) 字符串截取、split(String,int) 字符串分割、toLowerCase() 字符串所有字母小写。<br>通过查看subString底层的源码可知：其实是重新new了<strong>一个新的对象</strong>来接受字符串，并不是重新修改了原来的值，所以本质上原来的String对象<strong>并没有发生改变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-built_in">this</span><br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p><strong>StringBulider</strong>为什么又可变了呢？其实可以把他看作一个容器。<br>Stringbulid 和String可以相互转换。String -&gt; StringBuilder:可以使用StringBuilder的构造方法 <code>StringBuilder(String str)</code>构造一个字符串生成器，并初始化为指定的字符串内容。</p><p>StringBuilder -&gt; String:可以使用StringBuilder中的toString方法 <code>public String toString():</code>将当前StringBuilder对象转换为String对象。<br>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//String -&gt; StringBuilder</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(str);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br>        stringBuilder.append(<span class="hljs-string">&quot;World&quot;</span>);<br>        System.out.println(stringBuilder);<br>        <span class="hljs-comment">//StringBuilder -&gt; String</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> stringBuilder.toString();<br>        System.out.println(string);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p><strong>StringBuffer</strong> StringBulider一样同其实也可以被看作一个容器。字符串类可变，StringBuffer 可以通过 toString()方法转换成 String<br>String 可以通过 StringBuffer 的构造方法，转换成 StringBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>().toString();<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于@JsonFormat和@DataTimeFormat注解的日志相关问题</title>
    <link href="/61011741.github.io/2020/07/10/title/"/>
    <url>/61011741.github.io/2020/07/10/title/</url>
    
    <content type="html"><![CDATA[<h3 id="注解-JsonFormat主要是后端到前端的时间格式的转换-注解-DateTimeFormat主要是前端到后台的时间格式的转换"><a href="#注解-JsonFormat主要是后端到前端的时间格式的转换-注解-DateTimeFormat主要是前端到后台的时间格式的转换" class="headerlink" title="注解@JsonFormat主要是后端到前端的时间格式的转换  注解@DateTimeFormat主要是前端到后台的时间格式的转换"></a>注解@JsonFormat主要是后端到前端的时间格式的转换  注解@DateTimeFormat主要是前端到后台的时间格式的转换</h3><h3 id="运用示例-构造一个blog实体类：定义一些相关的成员变量对应数据库中表的字段"><a href="#运用示例-构造一个blog实体类：定义一些相关的成员变量对应数据库中表的字段" class="headerlink" title="运用示例: 构造一个blog实体类：定义一些相关的成员变量对应数据库中表的字段"></a>运用示例: 构造一个blog实体类：定义一些相关的成员变量对应数据库中表的字段</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 博客文章实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer blog_id;<span class="hljs-comment">// 博客id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> blog_title;<span class="hljs-comment">// 博客标题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> blog_content;<span class="hljs-comment">// 博客内容</span><br>    <span class="hljs-keyword">private</span> Date blog_date;<span class="hljs-comment">// 博客发布日期</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们不做任何处理，查出数据库中任何一篇博客时，得到的时间格式可能有点奇怪。比如如下：**”blog_date”: “2020-07-01T18:25:36.296+0000”** ，所以为了解决这个问题，就用到了 <strong>@JsonForMat</strong>这个注解。它能将日期格式化，此为 Jackson 框架提供的注解，将Date对象数据解析转换为JSON格式，该注解用于Date字段即可，同时指定期望JSON日期的格式。<br>在日期字段上加上注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br><br> <span class="hljs-meta">@JsonFormat(timezone = <span class="hljs-string">&quot;GMT+8&quot;</span>, pattern = <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)</span> <br><br>    <span class="hljs-keyword">private</span> Date blog_date;<span class="hljs-comment">// 博客发布日期</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 而在大多用户前台的门面的用户中心业务时，可能有比如出生日期，发表博客的日期这些内容，有时候会出现前端传递到后端的时间不一致的情况，所以就要加上 <strong>@DataTimeFormat</strong> 这个注解.此为Spring框架提供的注解，将JSON格式的日期信息信息解析转换并绑定到Date对象中，该注解用于Date字段即可，同时指定JSON日期的格式即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br><br>   <span class="hljs-meta">@DateTimeFormat(pattern=<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>  <br><br>    <span class="hljs-keyword">private</span> Date blog_date;<span class="hljs-comment">// 博客发布日期</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
